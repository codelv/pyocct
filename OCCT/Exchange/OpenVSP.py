# This file is part of pyOCCT which provides Python bindings to the OpenCASCADE
# geometry kernel.
#
# Copyright (C) 2016-2018  Laughlin Research, LLC (info@laughlinresearch.com)
#
# This library is free software; you can redistribute it and/or
# modify it under the terms of the GNU Lesser General Public
# License as published by the Free Software Foundation; either
# version 2.1 of the License, or (at your option) any later version.
#
# This library is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public
# License along with this library; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301 USA
from OCCT.BRep import BRep_Builder, BRep_Tool
from OCCT.BRepBuilderAPI import (BRepBuilderAPI_MakeFace,
                                 BRepBuilderAPI_MakeWire,
                                 BRepBuilderAPI_Sewing)
from OCCT.BRepCheck import BRepCheck_Analyzer, BRepCheck_NoError
from OCCT.BRepGProp import BRepGProp
from OCCT.GProp import GProp_GProps
from OCCT.Geom import Geom_Plane
from OCCT.GeomLib import GeomLib_IsPlanarSurface
from OCCT.IFSelect import (IFSelect_RetDone,
                           IFSelect_RetVoid)
from OCCT.STEPControl import STEPControl_Reader
from OCCT.ShapeAnalysis import ShapeAnalysis
from OCCT.ShapeFix import ShapeFix_Solid, ShapeFix_Wire
from OCCT.ShapeUpgrade import (ShapeUpgrade_ShapeDivideClosed,
                               ShapeUpgrade_UnifySameDomain)
from OCCT.TopAbs import TopAbs_COMPOUND, TopAbs_FACE
from OCCT.TopExp import TopExp_Explorer
from OCCT.TopoDS import TopoDS_Compound, TopoDS_Iterator, TopoDS_Shell

from OCCT.Topology import (CheckShape, ExploreShape, LinearProps,
                           CreateShape, FixShape)

__all__ = ["ImportVSP"]


class ImportVSP(object):
    """
    Tool for importing and pre-processing OpenVSP models.

    :param str fn: The full path to a file to import. If provided, the file
        extension will be used to guess which import method to call. For
        example, if the file ended with 'stp' or 'step', then the
        *import_step()* method is called during initialization.
    :param bool divide_closed: Option to divide closed faces.
    :param float tol: Tolerance for stitching the surfaces together.

    :raise TypeError: If a file is provided but the extension is not recognized
        or supported.
    """

    def __init__(self, fn=None, divide_closed=True, tol=1.0e-7):
        self._solids = []
        self._invalid = []
        self._divide = divide_closed
        self._tol = tol
        self._invalid_shapes = []

        if fn is not None:
            if fn.endswith('.step') or fn.endswith('.stp'):
                self.import_step(fn)
            else:
                raise TypeError('File extension not supported.')

    @property
    def num_solids(self):
        """
        :return: Number of valid solids.
        :rtype: int
        """
        return len(self._solids)

    @property
    def num_invalid(self):
        """
        :return: Number of invalid solids.
        :rtype: int
        """
        return len(self._invalid)

    @property
    def solids(self):
        """
        :return: List of all solids.
        :rtype: list(OCCT.TopoDS.TopoDS_Solid)
        """
        return self._solids

    @property
    def has_invalid(self):
        """
        :return: Check if any invalid solids are present.
        :rtype: bool
        """
        return self.num_invalid > 0

    @property
    def invalid_solids(self):
        """
        :return: List of all invalid solids.
        :rtype: list(OCCT.TopoDS.TopoDS_Solid)
        """
        return self._invalid

    @property
    def invalid_shapes(self):
        """
        :return: List of invalid shapes or sub-shapes.
        :rtype: list(OCCT.TopoDS.TopoDS_Shape)
        """
        return self._invalid_shapes

    def clear(self):
        """
        Clear any translated data.

        :return: None.
        """
        self._solids.clear()
        self._invalid.clear()

    def import_step(self, fn):
        """
        Import a STEP file generated by the OpenVSP.

        :param str fn: The full path to the file.

        :return: None.

        :raise RuntimeError: If the file cannot be read.
        """
        print('Importing OpenVSP STEP file...')

        # Build a compound for geometric sets
        compound = TopoDS_Compound()
        BRep_Builder().MakeCompound(compound)

        # Read file
        step_reader = STEPControl_Reader()
        status = step_reader.ReadFile(fn)
        if status not in [IFSelect_RetVoid, IFSelect_RetDone]:
            raise RuntimeError("Unable to read OpenVSP STEP file.")

        # TODO Convert to desired units
        # Interface_Static.SetCVal_("xstep.cascade.unit", "SOME UNIT HERE")

        # Transfer
        # OpenVSP STEP files result in one root and one shape (a compound)
        step_reader.TransferRoot(1)
        master_shape = step_reader.Shape(1)

        # Iterate over master shape to find compounds for geometric sets. These
        # sets contain the surfaces that make up the component.
        iterator = TopoDS_Iterator(master_shape, True, True)
        more = True
        while iterator.More() and more:
            print('--Processing a component...')
            # The compound
            compound = iterator.Value()
            # Hack to handle single component for now...
            if compound.ShapeType() != TopAbs_COMPOUND:
                compound = master_shape
                more = False

            solid, is_valid, invalid_shapes = _build_solid(compound,
                                                           self._divide)
            if is_valid:
                print('  Successfully built a solid.')
                self._solids.append(solid)
            else:
                print('  Failed to build a valid solid.')
                self._invalid.append(solid)
                self._invalid_shapes += invalid_shapes

            # Next shape
            iterator.Next()

        print('Finished.\n')


def _build_solid(compound, divide_closed):
    """
    Method to try and build a valid solid from an OpenVSP component.
    """
    # Get all the faces in the compound. The surfaces must be split. Discard
    # any with zero area.
    top_exp = TopExp_Explorer(compound, TopAbs_FACE)
    faces = []
    while top_exp.More():
        shape = top_exp.Current()
        face = CheckShape.to_face(shape)
        fprop = GProp_GProps()
        BRepGProp.SurfaceProperties_(face, fprop, 1.0e-7)
        a = fprop.Mass()
        if a <= 1.0e-7:
            top_exp.Next()
            continue
        faces.append(face)
        top_exp.Next()

    # Replace any planar B-Spline surfaces with planes
    non_planar_faces = []
    planar_faces = []
    for f in faces:
        hsrf = BRep_Tool.Surface_(f)
        try:
            is_pln = GeomLib_IsPlanarSurface(hsrf, 1.0e-7)
            if is_pln.IsPlanar():
                w = ShapeAnalysis.OuterWire_(f)
                # Fix the wire because they are usually degenerate edges in
                # the planar end caps.
                builder = BRepBuilderAPI_MakeWire()
                for e in ExploreShape.get_edges(w):
                    if LinearProps(e).length > 1.0e-7:
                        builder.Add(e)
                w = builder.Wire()
                fix = ShapeFix_Wire()
                fix.Load(w)
                geom_pln = Geom_Plane(is_pln.Plan())
                fix.SetSurface(geom_pln)
                fix.FixReorder()
                fix.FixConnected()
                fix.FixEdgeCurves()
                fix.FixDegenerated()
                w = fix.WireAPIMake()
                # Build the planar face
                fnew = BRepBuilderAPI_MakeFace(w, True).Face()
                planar_faces.append(fnew)
            else:
                non_planar_faces.append(f)
        except RuntimeError:
            non_planar_faces.append(f)

    # Make a compound of the faces
    shape = CreateShape.compound(non_planar_faces + planar_faces)

    # Split closed faces
    if divide_closed:
        divide = ShapeUpgrade_ShapeDivideClosed(shape)
        divide.Perform()
        shape = divide.Result()

    # Sew shape
    sew = BRepBuilderAPI_Sewing(1.0e-7)
    sew.Load(shape)
    sew.Perform()
    sewn_shape = sew.SewedShape()

    if sewn_shape.ShapeType() == TopAbs_FACE:
        face = sewn_shape
        sewn_shape = TopoDS_Shell()
        builder = BRep_Builder()
        builder.MakeShell(sewn_shape)
        builder.Add(sewn_shape, face)

    # Attempt to unify planar domains
    unify_shp = ShapeUpgrade_UnifySameDomain(sewn_shape, False, True, False)
    unify_shp.Build()
    shape = unify_shp.Shape()

    # Make solid
    shell = ExploreShape.get_shells(shape)[0]
    solid = ShapeFix_Solid().SolidFromShell(shell)

    # Limit tolerance
    FixShape.limit_tolerance(solid)

    # Check shape validity
    check_shp = BRepCheck_Analyzer(solid, True)
    if check_shp.IsValid():
        return solid, True, []
    else:
        invalid_shapes = _topods_iterator_check(solid, check_shp)
        return solid, False, invalid_shapes


def _topods_iterator_check(shape, check):
    """
    Iterate on the shape and print errors and store invalid shapes.
    """
    invalid = []
    it = TopoDS_Iterator(shape)
    while it.More():
        sub_shape = it.Value()
        result = check.Result(sub_shape)
        list_of_status = result.Status()
        for status in list_of_status:
            if status != BRepCheck_NoError:
                msg = '    {0}-->{1}'.format(status, sub_shape.ShapeType())
                print(msg)
                invalid.append(sub_shape)
        it.Next()
        invalid += _topods_iterator_check(sub_shape, check)

    return invalid
